<!DOCTYPE html>
<html lang="ru">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link rel="stylesheet" href="style.css" />
    <title>
      Домашнее задание неделя 19 (JS 11) "Асинхронность и работа с API."
    </title>
  </head>
  <body>
    <div class="root">
      <h1>Привет, Кот. Мои ответы на теоретические вопросы.</h1>
      <ol>
        <li>
          <span  class="question">Опишите разницу между синхронными и асинхронными функциями.</span>
          <p>
            Ответ: Синхронные функции являются блокирующими, а асинхронные -
            нет. В синхронных функциях одна операция должна завершиться,
            прежде чем будет запущена следующая операция. В этом случае скрипт
            выполняется строго по порядку операций, и выполнение скрипта
            приостанавливается, если одна из операций занимает очень много
            времени. 
            <br>Асинхронные функции обычно принимают callback-функцию в
            качестве параметра, и выполнение продолжается на следующей строке
            сразу после вызова асинхронной функции. Callback-функция
            вызывается только тогда, когда асинхронная операция завершена и стек вызовов
            пуст. Ресурсоемкие операции, такие как загрузка данных с веб
            сервера или запросы к базе данных, должны выполняться асинхронно, чтобы
            основной поток мог продолжать выполнять другие операции вместо
            блокировки до завершения этой долгой операции (в случае браузеров
            пользовательский интерфейс будет зависать).
          </p>
        </li>
        <li>
          <span  class="question">Сравните подходы работы с асинхронным кодом: сallbacks vs promises vs
          async / await</span>
            <p>Ответ: Callback — функция, которая вызывается в ответ на совершение некоторого события. Для этого функцию передают в качестве аргумента
            при вызове другой функции. Такой метод хорош в обработчиках событий, но для сложного асинхронного кода слишком неудобный и громоздкий.
            Промис (Promise) — это объект-обёртка для асинхронного кода. Он содержит в себе состояние: вначале pending («ожидание»), затем — одно из:
            fulfilled («выполнено успешно») или rejected («выполнено с ошибкой»). В понятиях цикла событий промис работает так же, как колбэк: функция,
            которая должна выполниться (resolve или reject), находится в окружении Web API, а при наступлении события — попадает в очередь задач, откуда
            потом — в стек вызова. Промисы придумали, чтобы организовывать асинхронный код последовательно.<br>
            Промисы решают проблему "ада" колбэков, их можно использовать для последовательного получения данных из нескольких конечных точек, но с меньшим
            количеством кода и более простыми методами.<br>
            Но есть еще один способ обработки данных и вызовов API - async / await. Асинхронная функция помечается специальным ключевым словом async.<br>
            Это функции, которые всегда возвращают промисы. Внутри асинхронных функций можно вызывать другие асинхронные функции, без каких-либо then() или
            колбэков, с помощью ключевого слова await. Таким образом, промис, который функция возвращает, автоматически разворачивается, и мы получаем значение, которое внутри промиса было.
          </p>
        </li>
        <li>
          <span  class="question">Что такое цикл событий (event loop) в JS ?</span>
          <p> Ответ: Цикл событий (event loop) отвечает за выполнение кода, сбор и обработку событий и выполнение
            подзадач из очереди. Идея событийного цикла очень проста. Есть бесконечный цикл, в котором движок JavaScript ожидает задачи, исполняет их и снова ожидает появления новых.<br>
            Общий алгоритм движка:<br>            
            пока есть задачи: выполнить их, начиная с самой старой;<br>
            бездействовать до появления новой задачи, а затем перейти к пункту 1.<br>
            Может так случиться, что задача поступает, когда движок занят чем-то другим, тогда она ставится в очередь. Эту очередь называют очередью макрозадач.  
            Задачи из очереди исполняются по правилу «первым пришёл – первым ушёл».<br>
            Помимо макрозадач существуют микрозадачи. Микрозадачи приходят только из кода. Обычно они создаются промисами: выполнение обработчика .then/catch/finally становится микрозадачей. Микрозадачи также используются «под капотом» await, т.к. это форма обработки промиса.
            Также есть специальная функция queueMicrotask(func), которая помещает func в очередь микрозадач.<br>            
            Сразу после каждой макрозадачи движок исполняет все задачи из очереди микрозадач перед тем, как выполнить следующую макрозадачу или отобразить изменения на странице, или сделать что-то ещё. Все микрозадачи завершаются до обработки каких-либо событий или рендеринга, или перехода к другой макрозадаче.
          </p>
        </li>
        <li>
          <span  class="question">Какая разница между «стеком вызовов» (call stack) и «очередью задач»
          (task queue)?</span>
          <p>Ответ: При вызове какой-то функции она попадает в так называемый стек вызовов.
            Стек — это структура данных, в которой элементы упорядочены так, что последний элемент, который попадает в стек, выходит из него первым (LIFO: last in, first out). Стек похож на стопку книг: та книга, которую мы кладём последней, находится сверху.
            В стеке вызовов хранятся функции, до которых дошёл интерпретатор, и которые надо выполнить.<br>
            В очередь задач попадают все события: загрузка скрипта, движение мыши пользователем, исполнение отложенных событий. Задачи из очереди исполняются по правилу «первым пришёл – первым ушёл».
          </p>
        </li>
        <li>
          <span  class="question">Какие версии HTTP-протокола вам известны?</span>
          <p>Ответ: 
            <ol>На данный момент есть четыре стандарта HTTP протокола:
              <li>
                Стандарт HTTP/0.9 – версия протокола HTTP 0.9 была разработана в 1991 году в ЦЕРН Тимом Бернерсом-Ли. Тим разработал HTTP протокол для облегчения доступа и создания навигации при помощи гипертекста. Протокол версии 0.9 был призван упорядочить взаимодействие между клиентом и сервером в сети. После появления стандарта HTTP/0.9 появилось разделение функций между клиентом и сервером при их взаимодействии. Стандарт HTTP/0.9 содержит в себе основы синтаксиса и семантики протокола HTTP.
              </li>
              <li>
                В 1996 году был выпущен информационный документ RFC 1945 (стандарт HTTP/1.0). Данный документ стал основой для реализации приложений и компонентов с использованием протокола HTTP версии 1.0. Кстати, разработчики могут идентифицировать свои приложения при передаче HTTP сообщений.
              </li>
              <li>
                В 1997 году была выпущена версия протокола HTTP1: был разработан стандарт HTTP/1.1 и описан он в документе RFC 2068. В 1999 году был доработан стандарт HTTP/1.1 (именно стандарт HTTP/1.1). Доработки коснулись: общего дизайна стандарта, формулировки и разъяснения некоторых терминов, исправлены опечатки, даны некоторые разъяснения по взаимодействию клиента и HTTP сервера в спорных ситуациях. Основным нововведением в версию протокола HTTP 1.1 был режим постоянного соединения, другими словами: за одно соединение можно было отправлять несколько HTTP запросов и получать несколько HTTP ответов в том порядке, в котором делались запросы. Вторым основным нововведение в версию протокола HTTP 1.1 является то, что теперь клиент при установке соединения с сервером должен обязательно посылать имя хоста в специальном поле HTTP заголовка (данное нововведение привело к массовому распространению виртуальных хостингов). На данный момент большинство приложений для своей работы используют HTTP протокол версии 1.1.
              </li>
              <li>
                2015 году была опубликована финальная версия черновика протокола HTTP 2, это еще не стандарт, но черновик нам «показывает» куда будет двигаться развитие интернета. Версия протокола HTTP 2 является бинарной. В версии протокола HTTP 2 будет поддерживаться мультиплексирование (объединение) запросов, поскольку появится объединение, появится и приоритет запросов и многое другое.
              </li>
            </ol>
          </p>
        </li>
        <li>
          <span  class="question">Какие знаете коды ответа (состояния) HTTP?</span>
          <p>
            Ответ: По коду статуса можно понять, что произошло с запросом.
            <ul> Если код начинается с:
                <li>2 — значит, запрос прошёл успешно;</li>
                <li>3 — запрос был перенаправлен;</li>
                <li>4 — с запросом что-то не так: ресурс не найден или у вас нет к нему доступа;</li>
                <li>5 — на сервере произошла какая-то ошибка.</li>
            </ul>
            <ul>Вот самые распространённые статусы:
                <li>200 OK;</li>
                <li>401 Unauthorized;</li>
                <li>403 Forbidden;</li>
                <li>404 Not Found;</li>
                <li>500 Internal Server Error.</li>
            </ul>
          </p>
        </li>
        <li>
          <span  class="question">Как клиент взаимодействует с сервером?</span>
          <p>Ответ: Обмен данными в интернете построен на принципе «запрос — ответ»: браузер формирует запрос, сервер его анализирует и отправляет ответ. Правила, по которым нужно формулировать запросы и ответы, определяет протокол — HTTP.</p>
        </li>
        <li>
          <span  class="question">Самостоятельно разберитесь, что такое Cross-Origin Resource Sharing?
          Как устранить проблемы с CORS?</span>
          <p>
            Ответ: Cross-Origin Resource Sharing (CORS) - совместное использование ресурсов между разными источниками    — это механизм, использующий дополнительные HTTP-заголовки, чтобы дать возможность браузеру получать разрешения на доступ к выбранным ресурсам с сервера на источнике (домене), отличном от того, что сайт использует в данный момент. Говорят, что агент пользователя делает запрос с другого источника (cross-origin HTTP request), если источник текущего документа отличается от запрашиваемого ресурса доменом, протоколом или портом.<br>
            В целях безопасности браузеры ограничивают cross-origin запросы, инициируемые скриптами. Например, XMLHttpRequest и Fetch API следуют политике одного источника (same-origin policy). Это значит, что web-приложения, использующие такие API, могут запрашивать HTTP-ресурсы только с того домена, с которого были загружены, пока не будут использованы CORS-заголовки. Механизм CORS поддерживает кросс-доменные запросы и передачу данных между браузером и web-серверами по защищённому соединению.<br>
            Стандарт Cross-Origin Resource Sharing работает с помощью добавления новых HTTP-заголовков, которые позволяют серверам описывать набор источников, которым разрешено читать информацию, запрашиваемую web-браузером.
          </p>  
          <p> 
            Наиболее распространенная проблема при работе с CORS заключается в том, что браузер блокирует запрос из-за  политики CORS. Браузер выдаст ошибку и отобразит в консоли следующее сообщение:<br>
            Access to XMLHttpRequest at 'http://localhost:8080/' from origin
            'http://localhost:3000' has been blocked by CORS policy:
            Response to preflight request doesn't pass access control
            check: No 'Access-Control-Allow-Origin' header is present
            on the requested resource.<br>
            Приведенная выше CORS-ошибка уведомляет пользователя о том, что браузер не может получить доступ к ресурсу (https://localhost:8080) из источника (https://localhost:3000), поскольку сервер его не одобрил. Это произошло из-за того, что сервер не ответил заголовком Access-Control-Allow-Origin с этим источником или символом * в ответе на предварительный CORS-запрос.<br>
            Запрос может быть заблокирован политикой CORS не только из-за невалидного источника, но и из-за неразрешенных заголовка HTTP, HTTP-метода или заголовка Cookie.
          </p>
          <p>
            Фундаментальная идея “исправления CORS” заключается в том, чтобы отвечать на OPTIONS запросы, отправленные от клиента, корректными заголовками. Есть много способов начать отвечать корректными CORS. Вы можете использовать прокси-сервер или какое-нибудь middleware на своем сервере.<br>
            1. Настройка вашего сервера<br>
            По умолчанию, если вы являетесь владельцем сервера, вам необходимо настроить на своем сервере CORS-ответы, и это единственный способ правильно решить проблему. Вы можете добиться этого несколькими способами из нескольких слоев вашего приложения. Самый распространенный способ — использовать обратный прокси-сервер (reverse-proxy), API-шлюз или любой другой сервис маршрутизации, который позволяет добавлять заголовки к ответам. Для этого можно использовать множество сервисов, и вот некоторые из них: HAProxy, Linkerd, Istio, Kong, nginx, Apache, Traefik. Если ваша инфраструктура содержит только приложение без каких-либо дополнительных слоев, то вы можете добавить поддержку CORS в код самого приложения.<br>
            2. Установка расширения для браузера<br>
            Использование расширения для браузера может быть быстрым и простым способом решения проблем с CORS в вашей среде разработки. Самым большим преимуществом использования расширения для браузера является то, что вам не нужно менять свой код или конфигурацию. С другой стороны, вам необходимо установить расширение в каждый браузер, который вы используете для тестирования своего веб-приложения.<br>
            3. Отключение CORS-проверок в браузере<br>
            Вы можете полностью отключить CORS-проверки в своем браузере. Чтобы отключить CORS-проверки в Google Chrome, нужно закрыть браузер и запустить его с флагами --disable-web-security и --user-data-dir. После запуска Google Chrome не будет отправлять предварительные CORS-запросы и не будет проверять CORS-заголовки.<br>
            4. Настройка прокси-сервера<br>
            Если вы ищете решение, которое не требует от вас изменения настроек браузера, вам следует обратить внимание на прокси-сервера. Эта опция поможет вам избавиться от CORS-ошибок, ничего не меняя в самом браузере. Идея подхода заключается в том, чтобы отправлять все запросы на ваш сервер, который затем перенаправит запрос реальной службе, которую вы хотите использовать. Вы можете создать прокси-сервер самостоятельно с помощью языка и платформы по вашему предпочтению. Вам потребуется настроить CORS и реализовать функционал передачи полученных запросов в другую службу.
          </p>
        </li>
        <li>
          <span  class="question">Самостоятельно разберитесь, что такое REST?</span>
          <p>
            Ответ: REST сейчас — один из самых распространённых стилей API в интернете.<br>
            REST (Representational State Transfer) — стиль общения компонентов, при котором все необходимые данные указываются в параметрах запроса.<br>
            Отличительная особенность этого стиля — это стиль построения адресов и выбор метода. Всё взаимодействие между клиентом и сервером сводится к 4 операциям (CRUD):
            <ul>
              <li>
                созданию чего-либо, например, объекта пользователя (create, C);
              </li>
              <li> 
                чтению (read, R);
              </li>
              <li>
                обновлению (update, U);
              </li>
              <li>
                удалению (delete, D).
              </li>
            </ul>

            Для каждой из операций есть собственный HTTP-метод:
            <ul>
              <li>
                POST для создания;
              </li>
              <li>
                GET для чтения;
              </li> 
              <li>
                PUT, PATCH для обновления (разница между PUT и PATCH в том, что PUT обновляет объект целиком, а PATCH — только указанное поле.);
              </li> 
              <li>
                DELETE для удаления.
              </li>
            </ul>

            Адрес, как правило, остаётся почти одинаковым, а детали запроса указываются в HTTP-методе и параметрах или теле запроса.
          </p>
        </li>
        <li>
          <span  class="question">Как посмотреть заголовки запроса к странице или API?</span>
          <p>Ответ: в инструментах разработчика во вкладке Network</p>
        </li>
        <li>
          <span  class="question">Что можно писать в параметре заголовков Content-Type ?</span>
          <p>Ответ: формат запрашиваемого контента: application/x-www-form-urlencoded, multipart/form-data, text/plain, application/json</p>
        </li>
        <li>
          <span  class="question">Давайте отправим информацию о собачке в API по адресу
          localhost/pets/add</span><br>
          <img src="img/dogJSON.png" alt="Объект о собачке" /><br />
          Как будет выглядеть fetch в таком случае?
          <p>Ответ:<br>
            <img src="img/fetch.png" alt="запрос" /><br />
          </p>
        </li>
      </ol>
    </div>
    <script src="index.js"></script>
  </body>
</html>
